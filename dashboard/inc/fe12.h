/**
 * @file fe12.h
 *
 * @brief This header file was generated by cantools version 41.0.2 Mon Jan  5 08:42:36 2026.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef FE12_H
#define FE12_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define FE12_VEHICLE_STATE_FRAME_ID (0x766u)
#define FE12_BMS_STATUS_FRAME_ID (0x380u)
#define FE12_STATUS_FRAME_ID (0x387u)
#define FE12_COOLING_LOOP_TEMPS_FRAME_ID (0x400u)
#define FE12_COOL_LOOP_PRESSURES_FRAME_ID (0x402u)
#define FE12_WHEEL_SPEED_REAR_FRAME_ID (0x401u)
#define FE12_TORQUE_REQUEST_FRAME_ID (0xc0u)
#define FE12_RANDOM_SHIT_FRAME_ID (0x500u)
#define FE12_DIAGNOSTIC_BMS_DATA_FRAME_ID (0x381u)
#define FE12_STRAIN_GAUGES_REAR_FRAME_ID (0x403u)
#define FE12_INPUTS_FRAME_ID (0x501u)
#define FE12_CURRENT_FRAME_ID (0x388u)
#define FE12_HIGH_LEVEL_BMS_DATA_FRAME_ID (0x382u)
#define FE12_BMS_VOLTAGES_FRAME_ID (0x383u)
#define FE12_BMS_TEMPS_FRAME_ID (0x384u)
#define FE12_SHOCK_ANGLES_REAR_FRAME_ID (0x404u)
#define FE12_RAW_THROTTLE_FRAME_ID (0x502u)

/* Frame lengths in bytes. */
#define FE12_VEHICLE_STATE_LENGTH (7u)
#define FE12_BMS_STATUS_LENGTH (5u)
#define FE12_STATUS_LENGTH (5u)
#define FE12_COOLING_LOOP_TEMPS_LENGTH (8u)
#define FE12_COOL_LOOP_PRESSURES_LENGTH (4u)
#define FE12_WHEEL_SPEED_REAR_LENGTH (4u)
#define FE12_TORQUE_REQUEST_LENGTH (8u)
#define FE12_RANDOM_SHIT_LENGTH (6u)
#define FE12_DIAGNOSTIC_BMS_DATA_LENGTH (4u)
#define FE12_STRAIN_GAUGES_REAR_LENGTH (8u)
#define FE12_INPUTS_LENGTH (3u)
#define FE12_CURRENT_LENGTH (4u)
#define FE12_HIGH_LEVEL_BMS_DATA_LENGTH (4u)
#define FE12_BMS_VOLTAGES_LENGTH (8u)
#define FE12_BMS_TEMPS_LENGTH (8u)
#define FE12_SHOCK_ANGLES_REAR_LENGTH (4u)
#define FE12_RAW_THROTTLE_LENGTH (4u)

/* Extended or standard frame types. */
#define FE12_VEHICLE_STATE_IS_EXTENDED (0)
#define FE12_BMS_STATUS_IS_EXTENDED (0)
#define FE12_STATUS_IS_EXTENDED (0)
#define FE12_COOLING_LOOP_TEMPS_IS_EXTENDED (0)
#define FE12_COOL_LOOP_PRESSURES_IS_EXTENDED (0)
#define FE12_WHEEL_SPEED_REAR_IS_EXTENDED (0)
#define FE12_TORQUE_REQUEST_IS_EXTENDED (0)
#define FE12_RANDOM_SHIT_IS_EXTENDED (0)
#define FE12_DIAGNOSTIC_BMS_DATA_IS_EXTENDED (0)
#define FE12_STRAIN_GAUGES_REAR_IS_EXTENDED (0)
#define FE12_INPUTS_IS_EXTENDED (0)
#define FE12_CURRENT_IS_EXTENDED (0)
#define FE12_HIGH_LEVEL_BMS_DATA_IS_EXTENDED (0)
#define FE12_BMS_VOLTAGES_IS_EXTENDED (0)
#define FE12_BMS_TEMPS_IS_EXTENDED (0)
#define FE12_SHOCK_ANGLES_REAR_IS_EXTENDED (0)
#define FE12_RAW_THROTTLE_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_LV_CHOICE (0u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_PRECHARGE_CHOICE (1u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_HV_ENABLED_CHOICE (2u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_DRIVE_CHOICE (3u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_STARTUP_CHOICE (5u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_DRV_FRM_LV_CHOICE (129u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_PRE_TM_OUT_CHOICE (130u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_BR_NOT_PRS_CHOICE (131u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_HV_OFF_DRV_CHOICE (132u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_SNSR_DSCRP_CHOICE (133u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_BSPD_TRIPD_CHOICE (134u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_SHTDWN_OPN_CHOICE (135u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_UNCALIBRTD_CHOICE (136u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_HARD_BSPD_CHOICE (137u)
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_MC_FAULT_CHOICE (138u)

#define FE12_BMS_STATUS_PEI_BMS_STATUS_NO_ERROR_CHOICE (0u)
#define FE12_BMS_STATUS_PEI_BMS_STATUS_CHARGE_MODE_CHOICE (1u)
#define FE12_BMS_STATUS_PEI_BMS_STATUS_BMS_TEMP_OVER_CHOICE (2u)
#define FE12_BMS_STATUS_PEI_BMS_STATUS_BMS_TEMP_UNDER_CHOICE (4u)
#define FE12_BMS_STATUS_PEI_BMS_STATUS_OVERVOLT_CHOICE (8u)
#define FE12_BMS_STATUS_PEI_BMS_STATUS_UNDERVOLT_CHOICE (16u)
#define FE12_BMS_STATUS_PEI_BMS_STATUS_OPEN_WIRE_CHOICE (32u)
#define FE12_BMS_STATUS_PEI_BMS_STATUS_MISMATCH_CHOICE (64u)
#define FE12_BMS_STATUS_PEI_BMS_STATUS_SPI_FAULT_CHOICE (128u)

#define FE12_BMS_VOLTAGES_PEI_GROUP_A_CHOICE (0u)
#define FE12_BMS_VOLTAGES_PEI_GROUP_B_CHOICE (1u)
#define FE12_BMS_VOLTAGES_PEI_GROUP_C_CHOICE (2u)
#define FE12_BMS_VOLTAGES_PEI_GROUP_D_CHOICE (3u)
#define FE12_BMS_VOLTAGES_PEI_GROUP_E_CHOICE (4u)
#define FE12_BMS_VOLTAGES_PEI_GROUP_F_CHOICE (5u)
#define FE12_BMS_VOLTAGES_PEI_GROUP_G_CHOICE (6u)
#define FE12_BMS_VOLTAGES_PEI_GROUP_H_CHOICE (7u)

/* Frame Names. */
#define FE12_VEHICLE_STATE_NAME "Vehicle_State"
#define FE12_BMS_STATUS_NAME "BMS_Status"
#define FE12_STATUS_NAME "Status"
#define FE12_COOLING_LOOP_TEMPS_NAME "Cooling_Loop_Temps"
#define FE12_COOL_LOOP_PRESSURES_NAME "Cool_Loop_Pressures"
#define FE12_WHEEL_SPEED_REAR_NAME "Wheel_Speed_Rear"
#define FE12_TORQUE_REQUEST_NAME "Torque_Request"
#define FE12_RANDOM_SHIT_NAME "Random_Shit"
#define FE12_DIAGNOSTIC_BMS_DATA_NAME "Diagnostic_BMS_Data"
#define FE12_STRAIN_GAUGES_REAR_NAME "Strain_Gauges_Rear"
#define FE12_INPUTS_NAME "Inputs"
#define FE12_CURRENT_NAME "Current"
#define FE12_HIGH_LEVEL_BMS_DATA_NAME "High_Level_BMS_Data"
#define FE12_BMS_VOLTAGES_NAME "BMS_Voltages"
#define FE12_BMS_TEMPS_NAME "BMS_Temps"
#define FE12_SHOCK_ANGLES_REAR_NAME "Shock_Angles_Rear"
#define FE12_RAW_THROTTLE_NAME "Raw_Throttle"

/* Signal Names. */
#define FE12_VEHICLE_STATE_DASHBOARD_HV_REQUESTED_NAME "Dashboard_HV_Requested"
#define FE12_VEHICLE_STATE_DASHBOARD_THROTTLE1_LEVEL_NAME "Dashboard_Throttle1_Level"
#define FE12_VEHICLE_STATE_DASHBOARD_THROTTLE2_LEVEL_NAME "Dashboard_Throttle2_Level"
#define FE12_VEHICLE_STATE_DASHBOARD_BRAKE_LEVEL_NAME "Dashboard_Brake_Level"
#define FE12_VEHICLE_STATE_DASHBOARD_STATE_NAME "Dashboard_State"
#define FE12_VEHICLE_STATE_DASHBOARD_VCU_TICKS_NAME "Dashboard_VCU_Ticks"
#define FE12_BMS_STATUS_PEI_BMS_STATUS_NAME "PEI_BMS_Status"
#define FE12_BMS_STATUS_PEI_SPI_ERROR_FLAGS_NAME "PEI_SPI_Error_Flags"
#define FE12_BMS_STATUS_PEI_MAX_FAULTING_IC_ADDRESS_NAME "PEI_Max_Faulting_IC_Address"
#define FE12_BMS_STATUS_PEI_COMMUNICATION_BREAK_ID_NAME "PEI_Communication_Break_ID"
#define FE12_STATUS_PEI_IMD_OK_NAME "PEI_IMD_OK"
#define FE12_STATUS_PEI_BMS_OK_NAME "PEI_BMS_OK"
#define FE12_STATUS_PEI_SHUTDOWN_FINAL_NAME "PEI_SHUTDOWN_FINAL"
#define FE12_STATUS_PEI_AIR_NEG_NAME "PEI_AIR_NEG"
#define FE12_STATUS_PEI_AIR_POS_NAME "PEI_AIR_POS"
#define FE12_STATUS_PEI_PRECHARGE_NAME "PEI_PRECHARGE"
#define FE12_STATUS_PEI_CURRENT_ADC_NAME "PEI_Current_ADC"
#define FE12_STATUS_PEI_CURRENT_REFERENCE_NAME "PEI_Current_Reference"
#define FE12_COOLING_LOOP_TEMPS_TELEM_NODE_INLET_WATER_TEMP_NAME "TelemNode_Inlet_Water_Temp"
#define FE12_COOLING_LOOP_TEMPS_TELEM_NODE_OUTLET_WATER_TEMP_NAME "TelemNode_Outlet_Water_Temp"
#define FE12_COOLING_LOOP_TEMPS_TELEM_NODE_AIR_INTO_RADIATOR_TEMP_NAME "TelemNode_Air_Into_Radiator_Temp"
#define FE12_COOLING_LOOP_TEMPS_TELEM_NODE_AIR_OUT_OF_RADIATOR_TEMP_NAME "TelemNode_Air_Out_Of_Radiator_Temp"
#define FE12_COOL_LOOP_PRESSURES_TELEM_NODE_INLET_WATER_PRESSURE_NAME "TelemNode_Inlet_Water_Pressure"
#define FE12_COOL_LOOP_PRESSURES_TELEM_NODE_OUTLET_WATER_PRESSURE_NAME "TelemNode_Outlet_Water_Pressure"
#define FE12_WHEEL_SPEED_REAR_TELEM_NODE_WHEEL_SPEED_REAR_RIGHT_NAME "TelemNode_Wheel_Speed_Rear_Right"
#define FE12_WHEEL_SPEED_REAR_TELEM_NODE_WHEEL_SPEED_REAR_LEFT_NAME "TelemNode_Wheel_Speed_Rear_Left"
#define FE12_TORQUE_REQUEST_DASHBOARD_TORQUE_NAME "Dashboard_Torque"
#define FE12_TORQUE_REQUEST_DASHBOARD_SPEED_NAME "Dashboard_Speed"
#define FE12_TORQUE_REQUEST_DASHBOARD_DIRECTION_NAME "Dashboard_Direction"
#define FE12_TORQUE_REQUEST_DASHBOARD_INVERTER_ENABLE_NAME "Dashboard_Inverter_Enable"
#define FE12_TORQUE_REQUEST_DASHBOARD_DISCHARGE_ENABLE_NAME "Dashboard_Discharge_Enable"
#define FE12_TORQUE_REQUEST_DASHBOARD_SPEED_MODE_ENABLE_NAME "Dashboard_Speed_Mode_Enable"
#define FE12_TORQUE_REQUEST_DASHBOARD_TORQUE_LIMIT_NAME "Dashboard_Torque_Limit"
#define FE12_RANDOM_SHIT_DASHBOARD_FRONT_STRAIN_GAUGE_NAME "Dashboard_Front_Strain_Gauge"
#define FE12_RANDOM_SHIT_DASHBOARD_FRONT_WHEEL_SPEED_NAME "Dashboard_Front_Wheel_Speed"
#define FE12_RANDOM_SHIT_DASHBOARD_TC_TORQUE_REQUEST_NAME "Dashboard_TC_Torque_Request"
#define FE12_DIAGNOSTIC_BMS_DATA_PEI_HI_TEMP_NAME "PEI_HI_Temp"
#define FE12_DIAGNOSTIC_BMS_DATA_PEI_SOC_NAME "PEI_SOC"
#define FE12_DIAGNOSTIC_BMS_DATA_PEI_PACK_VOLTAGE_NAME "PEI_Pack_Voltage"
#define FE12_STRAIN_GAUGES_REAR_TELEM_NODE_RL_TOE_STRAIN_GAUGE_NAME "TelemNode_RL_Toe_Strain_Gauge"
#define FE12_STRAIN_GAUGES_REAR_TELEM_NODE_RLUF_A_ARM_STRAIN_GAUGE_NAME "TelemNode_RLUF_A_Arm_Strain_Gauge"
#define FE12_STRAIN_GAUGES_REAR_TELEM_NODE_RLUB_A_ARM_STRAIN_GAUGE_NAME "TelemNode_RLUB_A_Arm_Strain_Gauge"
#define FE12_STRAIN_GAUGES_REAR_TELEM_NODE_RLLF_A_ARM_STRAIN_GAUGE_NAME "TelemNode_RLLF_A_Arm_Strain_Gauge"
#define FE12_INPUTS_DASHBOARD_KNOB1_NAME "Dashboard_Knob1"
#define FE12_INPUTS_DASHBOARD_KNOB2_NAME "Dashboard_Knob2"
#define FE12_INPUTS_DASHBOARD_DISPLAY_MODE_NAME "Dashboard_DISPLAY_MODE"
#define FE12_INPUTS_DASHBOARD_TC_NAME "Dashboard_TC"
#define FE12_INPUTS_DASHBOARD_MARKER_NAME "Dashboard_MARKER"
#define FE12_INPUTS_DASHBOARD_OVERTAKE_NAME "Dashboard_OVERTAKE"
#define FE12_CURRENT_PEI_CURRENT_NAME "PEI_Current"
#define FE12_HIGH_LEVEL_BMS_DATA_PEI_HI_TEMP_NAME "PEI_HI_Temp"
#define FE12_HIGH_LEVEL_BMS_DATA_PEI_PACK_VOLTAGE_NAME "PEI_Pack_Voltage"
#define FE12_BMS_VOLTAGES_PEI_SUBPACK_NAME "PEI_Subpack"
#define FE12_BMS_VOLTAGES_PEI_GROUP_NAME "PEI_Group"
#define FE12_BMS_VOLTAGES_PEI_VOLTAGE_1_NAME "PEI_Voltage_1"
#define FE12_BMS_VOLTAGES_PEI_VOLTAGE_2_NAME "PEI_Voltage_2"
#define FE12_BMS_VOLTAGES_PEI_VOLTAGE_3_NAME "PEI_Voltage_3"
#define FE12_BMS_TEMPS_PEI_SUBPACK_NAME "PEI_Subpack"
#define FE12_BMS_TEMPS_PEI_GROUP_NAME "PEI_Group"
#define FE12_BMS_TEMPS_PEI_TEMP_1_NAME "PEI_Temp_1"
#define FE12_BMS_TEMPS_PEI_TEMP_2_NAME "PEI_Temp_2"
#define FE12_BMS_TEMPS_PEI_TEMP_3_NAME "PEI_Temp_3"
#define FE12_SHOCK_ANGLES_REAR_TELEM_NODE_RL_SHOCK_ANGLE_NAME "TelemNode_RL_Shock_Angle"
#define FE12_SHOCK_ANGLES_REAR_TELEM_NODE_RR_SHOCK_ANGLE_NAME "TelemNode_RR_Shock_Angle"
#define FE12_RAW_THROTTLE_DASHBOARD_THROTTLE_1_NAME "Dashboard_Throttle_1"
#define FE12_RAW_THROTTLE_DASHBOARD_THROTTLE_2_NAME "Dashboard_Throttle_2"

/**
 * Signals in message Vehicle_State.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_vehicle_state_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_hv_requested;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_throttle1_level;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_throttle2_level;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_brake_level;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_state;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dashboard_vcu_ticks;
};

/**
 * Signals in message BMS_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_bms_status_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_bms_status;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pei_spi_error_flags;

    /**
     * Range: 0..9 (0..9 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_max_faulting_ic_address;

    /**
     * Range: -1..9 (-1..9 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t pei_communication_break_id;
};

/**
 * Signals in message Status.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_status_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_imd_ok;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_bms_ok;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_shutdown_final;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_air_neg;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_air_pos;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_precharge;

    /**
     * Range: 0..65535 (0..65535 Raw_ADC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pei_current_adc;

    /**
     * Range: -2048..2047 (-2048..2047 Raw_ADC)
     * Scale: 1
     * Offset: 0
     */
    int16_t pei_current_reference;
};

/**
 * Signals in message Cooling_Loop_Temps.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_cooling_loop_temps_t {
    /**
     * Range: -32768..32767 (-3276.8..3276.7 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t telem_node_inlet_water_temp;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t telem_node_outlet_water_temp;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t telem_node_air_into_radiator_temp;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t telem_node_air_out_of_radiator_temp;
};

/**
 * Signals in message Cool_Loop_Pressures.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_cool_loop_pressures_t {
    /**
     * Range: 0..100 (0..1 PSI)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t telem_node_inlet_water_pressure;

    /**
     * Range: 0..100 (0..1 PSI)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t telem_node_outlet_water_pressure;
};

/**
 * Signals in message Wheel_Speed_Rear.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_wheel_speed_rear_t {
    /**
     * Range: 0..65535 (0..65535 CPS/RPM)
     * Scale: 1
     * Offset: 0
     */
    uint16_t telem_node_wheel_speed_rear_right;

    /**
     * Range: 0..65535 (0..65535 CPS/RPM)
     * Scale: 1
     * Offset: 0
     */
    uint16_t telem_node_wheel_speed_rear_left;
};

/**
 * Signals in message Torque_Request.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_torque_request_t {
    /**
     * Range: -32768..32767 (-3276.8..3276.7 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t dashboard_torque;

    /**
     * Range: 0..65535 (0..65535 RPM)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dashboard_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_direction;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_inverter_enable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_discharge_enable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_speed_mode_enable;

    /**
     * Range: 0..65535 (0..6553.5 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t dashboard_torque_limit;
};

/**
 * Signals in message Random_Shit.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_random_shit_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dashboard_front_strain_gauge;

    /**
     * Range: 0..65535 (0..65535 RPM)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dashboard_front_wheel_speed;

    /**
     * Range: 0..65535 (0..6553.5 Nm)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t dashboard_tc_torque_request;
};

/**
 * Signals in message Diagnostic_BMS_Data.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_diagnostic_bms_data_t {
    /**
     * Range: 0..255 (0..255 C)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_hi_temp;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_soc;

    /**
     * Range: -32768..32767 (-32768..32767 V)
     * Scale: 1
     * Offset: 0
     */
    int16_t pei_pack_voltage;
};

/**
 * Signals in message Strain_Gauges_Rear.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_strain_gauges_rear_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t telem_node_rl_toe_strain_gauge;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t telem_node_rluf_a_arm_strain_gauge;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t telem_node_rlub_a_arm_strain_gauge;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t telem_node_rllf_a_arm_strain_gauge;
};

/**
 * Signals in message Inputs.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_inputs_t {
    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_knob1;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_knob2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_display_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_tc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_marker;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dashboard_overtake;
};

/**
 * Signals in message Current.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_current_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 A)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pei_current;
};

/**
 * Signals in message High_Level_BMS_Data.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_high_level_bms_data_t {
    /**
     * Range: 0..65535 (0..65.535 C)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t pei_hi_temp;

    /**
     * Range: 0..65535 (0..655.35 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pei_pack_voltage;
};

/**
 * Signals in message BMS_Voltages.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_bms_voltages_t {
    /**
     * Range: 0..4 (0..4 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_subpack;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_group;

    /**
     * Range: 0..65535 (0..655.35 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pei_voltage_1;

    /**
     * Range: 0..65535 (0..655.35 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pei_voltage_2;

    /**
     * Range: 0..65535 (0..655.35 V)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pei_voltage_3;
};

/**
 * Signals in message BMS_Temps.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_bms_temps_t {
    /**
     * Range: 0..4 (0..4 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_subpack;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pei_group;

    /**
     * Range: 0..65535 (0..65.535 C)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t pei_temp_1;

    /**
     * Range: 0..65535 (0..65.535 C)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t pei_temp_2;

    /**
     * Range: 0..65535 (0..65.535 C)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t pei_temp_3;
};

/**
 * Signals in message Shock_Angles_Rear.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_shock_angles_rear_t {
    /**
     * Range: 0..4095 (0..4095 Raw_ADC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t telem_node_rl_shock_angle;

    /**
     * Range: 0..4095 (0..4095 Raw_ADC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t telem_node_rr_shock_angle;
};

/**
 * Signals in message Raw_Throttle.
 *
 * All signal values are as on the CAN bus.
 */
struct fe12_raw_throttle_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dashboard_throttle_1;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dashboard_throttle_2;
};

/**
 * Pack message Vehicle_State.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_vehicle_state_pack(
    uint8_t *dst_p,
    const struct fe12_vehicle_state_t *src_p,
    size_t size);

/**
 * Unpack message Vehicle_State.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_vehicle_state_unpack(
    struct fe12_vehicle_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Vehicle_State.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_vehicle_state_init(struct fe12_vehicle_state_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_vehicle_state_dashboard_hv_requested_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_vehicle_state_dashboard_hv_requested_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_vehicle_state_dashboard_hv_requested_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_vehicle_state_dashboard_throttle1_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_vehicle_state_dashboard_throttle1_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_vehicle_state_dashboard_throttle1_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_vehicle_state_dashboard_throttle2_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_vehicle_state_dashboard_throttle2_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_vehicle_state_dashboard_throttle2_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_vehicle_state_dashboard_brake_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_vehicle_state_dashboard_brake_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_vehicle_state_dashboard_brake_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_vehicle_state_dashboard_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_vehicle_state_dashboard_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_vehicle_state_dashboard_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_vehicle_state_dashboard_vcu_ticks_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_vehicle_state_dashboard_vcu_ticks_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_vehicle_state_dashboard_vcu_ticks_is_in_range(uint16_t value);

/**
 * Pack message BMS_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_bms_status_pack(
    uint8_t *dst_p,
    const struct fe12_bms_status_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_bms_status_unpack(
    struct fe12_bms_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_bms_status_init(struct fe12_bms_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_bms_status_pei_bms_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_status_pei_bms_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_status_pei_bms_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_bms_status_pei_spi_error_flags_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_status_pei_spi_error_flags_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_status_pei_spi_error_flags_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_bms_status_pei_max_faulting_ic_address_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_status_pei_max_faulting_ic_address_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_status_pei_max_faulting_ic_address_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t fe12_bms_status_pei_communication_break_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_status_pei_communication_break_id_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_status_pei_communication_break_id_is_in_range(int8_t value);

/**
 * Pack message Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_status_pack(
    uint8_t *dst_p,
    const struct fe12_status_t *src_p,
    size_t size);

/**
 * Unpack message Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_status_unpack(
    struct fe12_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_status_init(struct fe12_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_status_pei_imd_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_status_pei_imd_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_status_pei_imd_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_status_pei_bms_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_status_pei_bms_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_status_pei_bms_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_status_pei_shutdown_final_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_status_pei_shutdown_final_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_status_pei_shutdown_final_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_status_pei_air_neg_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_status_pei_air_neg_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_status_pei_air_neg_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_status_pei_air_pos_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_status_pei_air_pos_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_status_pei_air_pos_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_status_pei_precharge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_status_pei_precharge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_status_pei_precharge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_status_pei_current_adc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_status_pei_current_adc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_status_pei_current_adc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fe12_status_pei_current_reference_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_status_pei_current_reference_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_status_pei_current_reference_is_in_range(int16_t value);

/**
 * Pack message Cooling_Loop_Temps.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_cooling_loop_temps_pack(
    uint8_t *dst_p,
    const struct fe12_cooling_loop_temps_t *src_p,
    size_t size);

/**
 * Unpack message Cooling_Loop_Temps.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_cooling_loop_temps_unpack(
    struct fe12_cooling_loop_temps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Cooling_Loop_Temps.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_cooling_loop_temps_init(struct fe12_cooling_loop_temps_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fe12_cooling_loop_temps_telem_node_inlet_water_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_cooling_loop_temps_telem_node_inlet_water_temp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_cooling_loop_temps_telem_node_inlet_water_temp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fe12_cooling_loop_temps_telem_node_outlet_water_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_cooling_loop_temps_telem_node_outlet_water_temp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_cooling_loop_temps_telem_node_outlet_water_temp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fe12_cooling_loop_temps_telem_node_air_into_radiator_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_cooling_loop_temps_telem_node_air_into_radiator_temp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_cooling_loop_temps_telem_node_air_into_radiator_temp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fe12_cooling_loop_temps_telem_node_air_out_of_radiator_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_cooling_loop_temps_telem_node_air_out_of_radiator_temp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_cooling_loop_temps_telem_node_air_out_of_radiator_temp_is_in_range(int16_t value);

/**
 * Pack message Cool_Loop_Pressures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_cool_loop_pressures_pack(
    uint8_t *dst_p,
    const struct fe12_cool_loop_pressures_t *src_p,
    size_t size);

/**
 * Unpack message Cool_Loop_Pressures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_cool_loop_pressures_unpack(
    struct fe12_cool_loop_pressures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Cool_Loop_Pressures.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_cool_loop_pressures_init(struct fe12_cool_loop_pressures_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_cool_loop_pressures_telem_node_inlet_water_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_cool_loop_pressures_telem_node_inlet_water_pressure_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_cool_loop_pressures_telem_node_inlet_water_pressure_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_cool_loop_pressures_telem_node_outlet_water_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_cool_loop_pressures_telem_node_outlet_water_pressure_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_cool_loop_pressures_telem_node_outlet_water_pressure_is_in_range(uint16_t value);

/**
 * Pack message Wheel_Speed_Rear.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_wheel_speed_rear_pack(
    uint8_t *dst_p,
    const struct fe12_wheel_speed_rear_t *src_p,
    size_t size);

/**
 * Unpack message Wheel_Speed_Rear.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_wheel_speed_rear_unpack(
    struct fe12_wheel_speed_rear_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Wheel_Speed_Rear.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_wheel_speed_rear_init(struct fe12_wheel_speed_rear_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_wheel_speed_rear_telem_node_wheel_speed_rear_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_wheel_speed_rear_telem_node_wheel_speed_rear_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_wheel_speed_rear_telem_node_wheel_speed_rear_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_wheel_speed_rear_telem_node_wheel_speed_rear_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_wheel_speed_rear_telem_node_wheel_speed_rear_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_wheel_speed_rear_telem_node_wheel_speed_rear_left_is_in_range(uint16_t value);

/**
 * Pack message Torque_Request.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_torque_request_pack(
    uint8_t *dst_p,
    const struct fe12_torque_request_t *src_p,
    size_t size);

/**
 * Unpack message Torque_Request.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_torque_request_unpack(
    struct fe12_torque_request_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Torque_Request.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_torque_request_init(struct fe12_torque_request_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fe12_torque_request_dashboard_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_torque_request_dashboard_torque_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_torque_request_dashboard_torque_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_torque_request_dashboard_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_torque_request_dashboard_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_torque_request_dashboard_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_torque_request_dashboard_direction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_torque_request_dashboard_direction_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_torque_request_dashboard_direction_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_torque_request_dashboard_inverter_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_torque_request_dashboard_inverter_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_torque_request_dashboard_inverter_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_torque_request_dashboard_discharge_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_torque_request_dashboard_discharge_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_torque_request_dashboard_discharge_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_torque_request_dashboard_speed_mode_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_torque_request_dashboard_speed_mode_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_torque_request_dashboard_speed_mode_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_torque_request_dashboard_torque_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_torque_request_dashboard_torque_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_torque_request_dashboard_torque_limit_is_in_range(uint16_t value);

/**
 * Pack message Random_Shit.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_random_shit_pack(
    uint8_t *dst_p,
    const struct fe12_random_shit_t *src_p,
    size_t size);

/**
 * Unpack message Random_Shit.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_random_shit_unpack(
    struct fe12_random_shit_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Random_Shit.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_random_shit_init(struct fe12_random_shit_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_random_shit_dashboard_front_strain_gauge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_random_shit_dashboard_front_strain_gauge_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_random_shit_dashboard_front_strain_gauge_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_random_shit_dashboard_front_wheel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_random_shit_dashboard_front_wheel_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_random_shit_dashboard_front_wheel_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_random_shit_dashboard_tc_torque_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_random_shit_dashboard_tc_torque_request_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_random_shit_dashboard_tc_torque_request_is_in_range(uint16_t value);

/**
 * Pack message Diagnostic_BMS_Data.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_diagnostic_bms_data_pack(
    uint8_t *dst_p,
    const struct fe12_diagnostic_bms_data_t *src_p,
    size_t size);

/**
 * Unpack message Diagnostic_BMS_Data.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_diagnostic_bms_data_unpack(
    struct fe12_diagnostic_bms_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Diagnostic_BMS_Data.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_diagnostic_bms_data_init(struct fe12_diagnostic_bms_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_diagnostic_bms_data_pei_hi_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_diagnostic_bms_data_pei_hi_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_diagnostic_bms_data_pei_hi_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_diagnostic_bms_data_pei_soc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_diagnostic_bms_data_pei_soc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_diagnostic_bms_data_pei_soc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fe12_diagnostic_bms_data_pei_pack_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_diagnostic_bms_data_pei_pack_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_diagnostic_bms_data_pei_pack_voltage_is_in_range(int16_t value);

/**
 * Pack message Strain_Gauges_Rear.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_strain_gauges_rear_pack(
    uint8_t *dst_p,
    const struct fe12_strain_gauges_rear_t *src_p,
    size_t size);

/**
 * Unpack message Strain_Gauges_Rear.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_strain_gauges_rear_unpack(
    struct fe12_strain_gauges_rear_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Strain_Gauges_Rear.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_strain_gauges_rear_init(struct fe12_strain_gauges_rear_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_strain_gauges_rear_telem_node_rl_toe_strain_gauge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_strain_gauges_rear_telem_node_rl_toe_strain_gauge_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_strain_gauges_rear_telem_node_rl_toe_strain_gauge_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_strain_gauges_rear_telem_node_rluf_a_arm_strain_gauge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_strain_gauges_rear_telem_node_rluf_a_arm_strain_gauge_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_strain_gauges_rear_telem_node_rluf_a_arm_strain_gauge_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_strain_gauges_rear_telem_node_rlub_a_arm_strain_gauge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_strain_gauges_rear_telem_node_rlub_a_arm_strain_gauge_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_strain_gauges_rear_telem_node_rlub_a_arm_strain_gauge_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_strain_gauges_rear_telem_node_rllf_a_arm_strain_gauge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_strain_gauges_rear_telem_node_rllf_a_arm_strain_gauge_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_strain_gauges_rear_telem_node_rllf_a_arm_strain_gauge_is_in_range(uint16_t value);

/**
 * Pack message Inputs.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_inputs_pack(
    uint8_t *dst_p,
    const struct fe12_inputs_t *src_p,
    size_t size);

/**
 * Unpack message Inputs.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_inputs_unpack(
    struct fe12_inputs_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Inputs.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_inputs_init(struct fe12_inputs_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_inputs_dashboard_knob1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_inputs_dashboard_knob1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_inputs_dashboard_knob1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_inputs_dashboard_knob2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_inputs_dashboard_knob2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_inputs_dashboard_knob2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_inputs_dashboard_display_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_inputs_dashboard_display_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_inputs_dashboard_display_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_inputs_dashboard_tc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_inputs_dashboard_tc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_inputs_dashboard_tc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_inputs_dashboard_marker_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_inputs_dashboard_marker_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_inputs_dashboard_marker_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_inputs_dashboard_overtake_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_inputs_dashboard_overtake_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_inputs_dashboard_overtake_is_in_range(uint8_t value);

/**
 * Pack message Current.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_current_pack(
    uint8_t *dst_p,
    const struct fe12_current_t *src_p,
    size_t size);

/**
 * Unpack message Current.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_current_unpack(
    struct fe12_current_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Current.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_current_init(struct fe12_current_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t fe12_current_pei_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_current_pei_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_current_pei_current_is_in_range(int16_t value);

/**
 * Pack message High_Level_BMS_Data.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_high_level_bms_data_pack(
    uint8_t *dst_p,
    const struct fe12_high_level_bms_data_t *src_p,
    size_t size);

/**
 * Unpack message High_Level_BMS_Data.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_high_level_bms_data_unpack(
    struct fe12_high_level_bms_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from High_Level_BMS_Data.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_high_level_bms_data_init(struct fe12_high_level_bms_data_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_high_level_bms_data_pei_hi_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_high_level_bms_data_pei_hi_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_high_level_bms_data_pei_hi_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_high_level_bms_data_pei_pack_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_high_level_bms_data_pei_pack_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_high_level_bms_data_pei_pack_voltage_is_in_range(uint16_t value);

/**
 * Pack message BMS_Voltages.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_bms_voltages_pack(
    uint8_t *dst_p,
    const struct fe12_bms_voltages_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Voltages.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_bms_voltages_unpack(
    struct fe12_bms_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_Voltages.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_bms_voltages_init(struct fe12_bms_voltages_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_bms_voltages_pei_subpack_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_voltages_pei_subpack_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_voltages_pei_subpack_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_bms_voltages_pei_group_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_voltages_pei_group_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_voltages_pei_group_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_bms_voltages_pei_voltage_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_voltages_pei_voltage_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_voltages_pei_voltage_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_bms_voltages_pei_voltage_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_voltages_pei_voltage_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_voltages_pei_voltage_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_bms_voltages_pei_voltage_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_voltages_pei_voltage_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_voltages_pei_voltage_3_is_in_range(uint16_t value);

/**
 * Pack message BMS_Temps.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_bms_temps_pack(
    uint8_t *dst_p,
    const struct fe12_bms_temps_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Temps.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_bms_temps_unpack(
    struct fe12_bms_temps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_Temps.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_bms_temps_init(struct fe12_bms_temps_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_bms_temps_pei_subpack_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_temps_pei_subpack_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_temps_pei_subpack_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t fe12_bms_temps_pei_group_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_temps_pei_group_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_temps_pei_group_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_bms_temps_pei_temp_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_temps_pei_temp_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_temps_pei_temp_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_bms_temps_pei_temp_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_temps_pei_temp_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_temps_pei_temp_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_bms_temps_pei_temp_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_bms_temps_pei_temp_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_bms_temps_pei_temp_3_is_in_range(uint16_t value);

/**
 * Pack message Shock_Angles_Rear.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_shock_angles_rear_pack(
    uint8_t *dst_p,
    const struct fe12_shock_angles_rear_t *src_p,
    size_t size);

/**
 * Unpack message Shock_Angles_Rear.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_shock_angles_rear_unpack(
    struct fe12_shock_angles_rear_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Shock_Angles_Rear.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_shock_angles_rear_init(struct fe12_shock_angles_rear_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_shock_angles_rear_telem_node_rl_shock_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_shock_angles_rear_telem_node_rl_shock_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_shock_angles_rear_telem_node_rl_shock_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_shock_angles_rear_telem_node_rr_shock_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_shock_angles_rear_telem_node_rr_shock_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_shock_angles_rear_telem_node_rr_shock_angle_is_in_range(uint16_t value);

/**
 * Pack message Raw_Throttle.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int fe12_raw_throttle_pack(
    uint8_t *dst_p,
    const struct fe12_raw_throttle_t *src_p,
    size_t size);

/**
 * Unpack message Raw_Throttle.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int fe12_raw_throttle_unpack(
    struct fe12_raw_throttle_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from Raw_Throttle.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int fe12_raw_throttle_init(struct fe12_raw_throttle_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_raw_throttle_dashboard_throttle_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_raw_throttle_dashboard_throttle_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_raw_throttle_dashboard_throttle_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t fe12_raw_throttle_dashboard_throttle_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double fe12_raw_throttle_dashboard_throttle_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool fe12_raw_throttle_dashboard_throttle_2_is_in_range(uint16_t value);


#ifdef __cplusplus
}
#endif

#endif
